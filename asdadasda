local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local verificacionesRealizadas = {} -- Tabla para trackear verificaciones por UserID
local TIEMPO_COOLDOWN = 30 -- segundos antes de permitir otra verificación del mismo usuario
local jugadoresTrackeados = {} -- Guardará info de jugadores que ya procesamos
local jugadoresBots = {}
local TIEMPO_RESPAWN_COOLDOWN = 5 -- segundos para evitar spam de re-queue

local character = player.Character or player.CharacterAdded:Wait()
local HRP = character:WaitForChild("HumanoidRootPart")
local droppVariable = true
local Hum = character:FindFirstChildOfClass("Humanoid")
-- Variables para el sistema de detección de drops
local DropFolder = workspace:WaitForChild("Ignored"):WaitForChild("Drop")
local totalDrops12750 = 0
local valorTotal12750 = 0
local trackedDrops = {} -- guardamos los drops que son 12750
local limiteDHC = tonumber(getgenv().AutofarmSettings["DHC"]) or 0
local limiteFinalDHC = tonumber(getgenv().AutofarmSettings["FinallyDHC"]) or 0
local dineroTotalRecogido = 0
local lastDropState = true
local checkingAPI = false

-- Función para formatear números con comas
local function formatNumber(num)
    local formatted = tostring(num)
    while true do
        formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
        if k == 0 then
            break
        end
    end
    return "$" .. formatted
end

function optimizarJugador(char)
    if not char then return end

    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Transparency = 1
            part.CanCollide = false
            part.CastShadow = false
        elseif part:IsA("Decal") or part:IsA("Texture") then
            part.Transparency = 1
        elseif part:IsA("ParticleEmitter") or part:IsA("Trail") then
            part.Enabled = false
        elseif part:IsA("Sound") then
            part.Volume = 0
        end
    end
end

local function hacerDropInvisible(drop)
    if drop:IsA("Part") then
        drop.Transparency = 1
        drop.CanCollide = false
        
        -- Ocultar todos sus descendientes
        for _, child in ipairs(drop:GetDescendants()) do
            if child:IsA("BasePart") then
                child.Transparency = 1
            elseif child:IsA("Decal") or child:IsA("Texture") or child:IsA("SurfaceGui") then
                child.Transparency = 1
            elseif child:IsA("ParticleEmitter") or child:IsA("Trail") then
                child.Enabled = false
            end
        end
    end
end

local function sendWebhook(webhookUrl, embedData)
    if not webhookUrl or webhookUrl == "" or webhookUrl == "acaloswebbhok" then
        return -- No enviar si no hay URL válida
    end
    
    pcall(function()
        local payload = {
            embeds = {embedData}
        }
        
        request({
            Url = webhookUrl,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = HttpService:JSONEncode(payload)
        })
    end)
end

-- Función modular para advertencias
local function WarningHook(mensaje)
    if not getgenv().AutofarmSettings or not getgenv().AutofarmSettings.Webhook or not getgenv().AutofarmSettings.Webhook.WarningURL then
        return -- No hacer nada si no hay URL de warning configurada
    end
    
    local embed = {
        title = "⚠️ Warning!",
        description = mensaje,
        color = 16776960, -- Amarillo/Naranja
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    sendWebhook(getgenv().AutofarmSettings.Webhook.WarningURL, embed)
end

-- Sistema de control de drop
local function sendDropState(dropState)
    if checkingAPI then return end
    checkingAPI = true
    
    pcall(function()
        request({
            Url = "https://kamaik-autofarm.uk/api/drop/toggle",
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({
                key = script_key,
                drop = dropState
            })
        })
    end)
    
    checkingAPI = false
end

local function controlDropState()
    -- Verificar límite final primero
    if limiteFinalDHC > 0 then
        local dineroTotalAcumulado = valorTotal12750 + dineroTotalRecogido
        
        if dineroTotalAcumulado >= limiteFinalDHC then
            -- Límite final alcanzado - DETENER TODO
            if lastDropState ~= false then
                sendDropState(false)
                lastDropState = false
                droppVariable = false
            end
            return
        end
    end
    
    -- Si limiteDHC es 0, solo enviar true y no hacer más lógica
    if limiteDHC == 0 then
        if not lastDropState or lastDropState ~= true then
            sendDropState(true)
            lastDropState = true
            droppVariable = true
        end
        return
    end
    
    -- Lógica normal cuando limiteDHC > 0
    local shouldDrop = valorTotal12750 < limiteDHC
    
    -- Solo enviar a la API si el estado cambió
    if lastDropState ~= shouldDrop then
        sendDropState(shouldDrop)
        lastDropState = shouldDrop
        droppVariable = shouldDrop
    end
end

--- UI CREATION
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true
ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

local function addCorner(uiObject, scale, offset)
    local c = Instance.new("UICorner", uiObject)
    c.CornerRadius = UDim.new(scale or 12, offset or 12)
end

local MainFrame = Instance.new("Frame")
local Titulo = Instance.new("TextLabel")
local Frame1 = Instance.new("Frame")
local Frame2 = Instance.new("Frame")
local Frame3 = Instance.new("Frame")
local ServerCount = Instance.new("TextLabel")
local DropTotal = Instance.new("TextLabel")
local StatusPe = Instance.new("TextLabel")
local ServerCount2 = Instance.new("TextLabel")
local DropTotal2 = Instance.new("TextLabel")

-- UI Setup
MainFrame.Size = UDim2.new(1, 0, 1, 0)
MainFrame.ZIndex = 1
MainFrame.BorderSizePixel = 0
MainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)     
MainFrame.Parent = ScreenGui

Frame1.Size = UDim2.new(0, 417, 0, 266)
Frame1.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame1.ZIndex = 2
Frame1.BorderSizePixel = 0
Frame1.BackgroundColor3 = Color3.fromRGB(93, 93, 93)     
Frame1.AnchorPoint = Vector2.new(0.5, 0.5)
Frame1.Parent = MainFrame
addCorner(Frame1, 0, 40)

Frame2.Size = UDim2.new(0, 413, 0, 263)
Frame2.Position = UDim2.new(0, 2, 0, 2)
Frame2.ZIndex = 3
Frame2.BorderSizePixel = 0
Frame2.BackgroundColor3 = Color3.fromRGB(0, 0, 0)     
Frame2.Parent = Frame1
addCorner(Frame2, 0, 40)

Frame3.Size = UDim2.new(0, 413, 0, 2)
Frame3.Position = UDim2.new(0, 0, 0.798, 2)
Frame3.ZIndex = 4
Frame3.BorderSizePixel = 0
Frame3.BackgroundColor3 = Color3.fromRGB(93, 93, 93)     
Frame3.Parent = Frame2

-- UI Labels
ServerCount.Parent = Frame2
ServerCount.BackgroundTransparency = 1
ServerCount.Position = UDim2.new(0.022, 0, 0.077, 0)
ServerCount.Size = UDim2.new(0, 200, 0, 50)
ServerCount.Text = "# Server Cash:"
ServerCount.ZIndex = 4
ServerCount.TextColor3 = Color3.fromRGB(255, 0, 4)
ServerCount.TextSize = 20

DropTotal.Parent = Frame2
DropTotal.BackgroundTransparency = 1
DropTotal.Position = UDim2.new(0.022, 0, 0.426, 0)
DropTotal.Size = UDim2.new(0, 200, 0, 50)
DropTotal.Text = "# Count Drops:"
DropTotal.ZIndex = 4
DropTotal.TextColor3 = Color3.fromRGB(255, 0, 4)
DropTotal.TextSize = 20

StatusPe.Parent = Frame2
StatusPe.BackgroundTransparency = 1
StatusPe.Position = UDim2.new(0.256, 0, 0.805, 0)
StatusPe.Size = UDim2.new(0, 200, 0, 50)
StatusPe.Text = "Loading Modules..."
StatusPe.ZIndex = 4
StatusPe.TextColor3 = Color3.fromRGB(81, 81, 81)
StatusPe.TextSize = 20

ServerCount2.Parent = Frame2
ServerCount2.BackgroundTransparency = 1
ServerCount2.Position = UDim2.new(0.315, 0, 0.234, 0)
ServerCount2.Size = UDim2.new(0, 200, 0, 50)
ServerCount2.Text = "Load..."
ServerCount2.ZIndex = 4
ServerCount2.TextColor3 = Color3.fromRGB(0, 255, 102)
ServerCount2.TextSize = 22

DropTotal2.Parent = Frame2
DropTotal2.BackgroundTransparency = 1
DropTotal2.Position = UDim2.new(0.315, 0, 0.579, 0)
DropTotal2.Size = UDim2.new(0, 200, 0, 50)
DropTotal2.Text = "Load..."
DropTotal2.ZIndex = 4
DropTotal2.TextColor3 = Color3.fromRGB(0, 255, 102)
DropTotal2.TextSize = 22

-- Función para obtener valor de un drop
local function obtenerValor(drop)
    if not drop:IsA("Part") or not drop.Name:find("Money") then
        return nil
    end
    -- Primero intentamos con NumberValue o IntValue
    local valObj = drop:FindFirstChildOfClass("NumberValue") or drop:FindFirstChildOfClass("IntValue")
    if valObj then
        return tonumber(valObj.Value)
    end
    -- Si no tiene Value, intentamos leer el texto de un BillboardGui
    local bill = drop:FindFirstChildWhichIsA("BillboardGui")
    if bill then
        local label = bill:FindFirstChildWhichIsA("TextLabel")
        if label then
            local text = label.Text
            local num = text:gsub("%D", "") -- quitamos todo lo que no sea dígito
            return tonumber(num)
        end
    end
    return nil
end

-- Función para actualizar la UI con los valores de drops
local function actualizarUI()
    ServerCount2.Text = formatNumber(valorTotal12750)
    DropTotal2.Text = tostring(totalDrops12750)
    controlDropState()
end

-- Inicializar drops existentes
for _, drop in ipairs(DropFolder:GetChildren()) do
    local valor = obtenerValor(drop)
    if valor == 12750 then
        totalDrops12750 += 1
        valorTotal12750 += valor
        trackedDrops[drop] = valor
    end
end
actualizarUI()

-- Eventos de drops
DropFolder.ChildAdded:Connect(function(drop)
    task.wait(0.1)

    hacerDropInvisible(drop)
    
    local valor = obtenerValor(drop)
    if valor == 12750 then
        totalDrops12750 += 1
        valorTotal12750 += valor
        trackedDrops[drop] = valor
        actualizarUI()
    end
end)

DropFolder.ChildRemoved:Connect(function(drop)
    if trackedDrops[drop] then
        local valor = trackedDrops[drop]
        totalDrops12750 -= 1
        
        -- Sumar al total recogido
        dineroTotalRecogido += valor
        
        valorTotal12750 -= valor
        trackedDrops[drop] = nil
        actualizarUI()
    end
end)
-- CONFIG
local finalPos1 = Vector3.new(-663.161, -37.3, -286.472) -- Posición final para no-clientes y clientes completados
local finalPos2 = Vector3.new(-237.40, -6.11, -350.44) -- Posición inicial para clientes (discoteca)

-- Posiciones para dropear dinero
local dropPositions = {
    [1] = CFrame.new(-290.68, -13, -355.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [2] = CFrame.new(-275.68, -13, -355.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [3] = CFrame.new(-260.68, -13, -355.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [4] = CFrame.new(-255.68, -13, -355.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [5] = CFrame.new(-240.68, -13, -355.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    ----
    [6] = CFrame.new(-290, -13, -365.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [7] = CFrame.new(-275, -13, -365.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [8] = CFrame.new(-260, -13, -365.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [9] = CFrame.new(-255, -13, -365.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [10] = CFrame.new(-240, -13, -365.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    ----
    [11] = CFrame.new(-290.68, -13, -375.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [12] = CFrame.new(-275.68, -13, -375.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [13] = CFrame.new(-260.68, -13, -375.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [14] = CFrame.new(-255.68, -13, -375.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [15] = CFrame.new(-240.68, -13, -375.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    ---
    [16] = CFrame.new(-290.68, -13, -385.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [17] = CFrame.new(-275.68, -13, -385.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [18] = CFrame.new(-260.68, -13, -385.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [19] = CFrame.new(-255.68, -13, -385.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [20] = CFrame.new(-240.68, -13, -385.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    --
    [21] = CFrame.new(-290.68, -13, -395.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [22] = CFrame.new(-275.68, -13, -395.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [23] = CFrame.new(-260.68, -13, -395.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [24] = CFrame.new(-255.68, -13, -395.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [25] = CFrame.new(-240.68, -13, -395.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    --
    [26] = CFrame.new(-290.68, -13, -405.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [27] = CFrame.new(-275.68, -13, -405.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [28] = CFrame.new(-260.68, -13, -405.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [29] = CFrame.new(-255.68, -13, -405.42) * CFrame.Angles(0, math.rad(-3.43), 0),
    [30] = CFrame.new(-240.68, -13, -405.42) * CFrame.Angles(0, math.rad(-3.43), 0),
}

-- ESTADO
local queue = {}
local isProcessing = false
local isDroppingMoney = false
local currentDropIndex = 1
local isPositioned = false -- Flag para saber si estoy en posición de dropeo

-- Sistema de vuelo simplificado
local Kamaik = {
    Vuelo = {
        vueloThread = nil,
        vueloActivo = false,
        posVuelo = false,
        Core = nil,
    },
    positions = dropPositions
}

-- Función para verificar si estoy en posición de dropeo
local function checkIfPositioned()
    if not HRP then return false end
    
    local currentPos = HRP.Position
    for _, dropPos in pairs(dropPositions) do
        local distance = (currentPos - dropPos.Position).Magnitude
        if distance < 20 then -- Si estoy cerca de alguna posición de dropeo
            return true
        end
    end
    return false
end

-- Función para limpiar vuelo
function limpiarVuelo()
    Kamaik.Vuelo.vueloActivo = false
    Kamaik.Vuelo.posVuelo = nil
    Kamaik.Vuelo.vueloThread = false

    if workspace:FindFirstChild("Core") then
        workspace.Core:Destroy()
    end

    local char = player.Character
    if char then
        local root = char:FindFirstChild("HumanoidRootPart")
        if root then root.CanCollide = true end
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then humanoid.PlatformStand = false end
    end
end

-- Función para activar vuelo
function activarVueloNuevo(targetCFrame)
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local root = character:WaitForChild("HumanoidRootPart")

    root.CFrame = targetCFrame

    limpiarVuelo()
    task.wait()

    if workspace:FindFirstChild("Core") then
        workspace.Core:Destroy()
    end

    local Core = Instance.new("Part")
    Core.Name = "Core"
    Core.Size = Vector3.new(0.05, 0.05, 0.05)
    Core.Anchored = false
    Core.CanCollide = false
    Core.Transparency = 1
    Core.Parent = workspace

    local weld = Instance.new("Weld", Core)
    weld.Part0 = Core
    weld.Part1 = character:WaitForChild("LowerTorso")
    weld.C0 = CFrame.new(0, 0, 0)

    local torso = Core
    Kamaik.Vuelo.Core = Core
    Kamaik.Vuelo.vueloActivo = true
    Kamaik.Vuelo.vueloThread = true

    root.CanCollide = false
    local humanoid = character:WaitForChild("Humanoid")
    humanoid.PlatformStand = true

    task.spawn(function()
        local pos = Instance.new("BodyPosition", torso)
        local gyro = Instance.new("BodyGyro", torso)
        pos.Name = "EPIXPOS"
        pos.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        pos.Position = targetCFrame.Position
        gyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
        gyro.CFrame = targetCFrame

        while Kamaik.Vuelo.vueloActivo do
            if Kamaik.Vuelo.posVuelo then
                pos.Position = Kamaik.Vuelo.posVuelo.Position
                gyro.CFrame = Kamaik.Vuelo.posVuelo
            else
                pos.Position = targetCFrame.Position
                gyro.CFrame = targetCFrame
            end
            task.wait()
        end
    end)
    task.wait(1)
    optimizarJugador(character)
end

local function esCliente(key, userId)
    -- Verificar si ya se consultó este usuario recientemente
    local ahora = tick()
    if verificacionesRealizadas[userId] then
        local tiempoTranscurrido = ahora - verificacionesRealizadas[userId]
        if tiempoTranscurrido < TIEMPO_COOLDOWN then
            return nil, false, true -- Retornamos un tercer valor para indicar que fue cacheado
        end
    end
    
    -- Marcar que estamos verificando este usuario
    verificacionesRealizadas[userId] = ahora
    
    local success, response = pcall(function()
        return request({
            Url = "https://kamaik-autofarm.uk/api/clientes/check",
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({
                key = key,
                userId = userId,
            })
        })
    end)

    if success and response.Success then
        local decodeSuccess, data = pcall(function()
            return HttpService:JSONDecode(response.Body)
        end)

        if decodeSuccess and type(data) == "table" then
            return data, data.isBot == true, false
        end
    end
    
    -- Si falla, remover de cache para permitir reintento
    verificacionesRealizadas[userId] = nil
    return nil, false, false
end

-- Función para verificar si una posición está ocupada
local function isPositionOccupied(cframe)
    local characterRange = 10
    
    for _, otroPlayer in ipairs(Players:GetPlayers()) do
        if otroPlayer ~= player then
            local otroChar = otroPlayer.Character
            local hrp = otroChar and otroChar:FindFirstChild("HumanoidRootPart")
            
            if hrp then
                local distancia = (hrp.Position - cframe.Position).Magnitude
                if distancia < characterRange then
                    local userId = otroPlayer.UserId
                    
                    -- 1. Revisar si ya está cacheado
                    if jugadoresBots[userId] ~= nil then
                        if jugadoresBots[userId] == true then
                            return true -- ocupado por un bot
                        else
                            continue -- jugador real, lo ignoro
                        end
                    end
                    
                    -- 2. Revisar si lo tengo trackeado como jugador real
                    local jugadorData = jugadoresTrackeados[userId]
                    if jugadorData then
                        jugadoresBots[userId] = false
                        continue
                    end
                    
                    -- 3. Consultar al sistema de verificación
                    local _, esBot = esCliente(script_key, userId)
                    if esBot then
                        jugadoresBots[userId] = true
                        return true
                    else
                        jugadoresBots[userId] = false
                    end
                end
            end
        end
    end
    
    return false -- Ningún bot cerca
end

-- Funciones VIP Commands
local function summonPlayer(targetPlayer)
    if not targetPlayer then return false end
    
    local success = pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("MainEvent"):FireServer("VIP_CMD", "Summon", targetPlayer)
    end)
    
    return success
end

local function kickPlayer(targetPlayer, playerName)
    if not targetPlayer and not playerName then return false end
    
    -- Primero hacer shout de advertencia
    local success1 = pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("MainEvent"):FireServer("Shout", playerName .. ", you have 10 seconds to leave the server or you will be kicked.")
    end)
    
    -- Luego programar el kick después de 10 segundos
    task.spawn(function()
        task.wait(10)
        pcall(function()
            if targetPlayer and targetPlayer.Parent then -- Verificar si aún está en el servidor
                game:GetService("ReplicatedStorage"):WaitForChild("MainEvent"):FireServer("VIP_CMD", "Kick", targetPlayer)
            end
        end)
    end)
    
    return success1
end

-- Función API para verificar si es cliente

-- API Functions
local function registrarBot(key, userId, dhcValue, statusValue, colorValue)
    pcall(function()
        request({
            Url = "https://kamaik-autofarm.uk/api/bots/add",
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({
                key = key,
                userId = userId,
                dhc = dhcValue,
                status = statusValue,
                color = colorValue
            })
        })
    end)
end

local function ActualizarCliente(key, userId, restanteValue)
    pcall(function()
        request({
            Url = "https://kamaik-autofarm.uk/api/clientes/update",
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({
                key = key,
                userId = userId,
                restante = restanteValue,
            })
        })
    end)
end

local function BorrarCliente(key, userId, playerName, dhcAmount, newMoney)
    pcall(function()
        request({
            Url = "https://kamaik-autofarm.uk/api/clientes/delete",
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({
                key = key,
                userId = userId
            })
        })
    end)
    
    if jugadoresTrackeados[userId] then
        jugadoresTrackeados[userId].esCliente = false
        jugadoresTrackeados[userId].clientData = nil
        jugadoresTrackeados[userId].siendoTransportado = false
    end
    
    -- Webhook de cliente completado
    if getgenv().AutofarmSettings 
    and getgenv().AutofarmSettings.Webhook 
    and getgenv().AutofarmSettings.Webhook.CompleteURL then
        
        local oldMoney = (newMoney or 0) - (dhcAmount or 0)

        local avatarUrl
        pcall(function()
            local res = request({
                Url = "https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds=" 
                      .. tostring(userId) .. "&size=420x420&format=Png&isCircular=false",
                Method = "GET"
            })
            if res and res.Body then
                local data = HttpService:JSONDecode(res.Body)
                if data and data.data and data.data[1] and data.data[1].imageUrl then
                    avatarUrl = data.data[1].imageUrl
                end
            end
        end)

        local embed = {
            title = "Vouch - " .. (playerName or "Desconocido"),
            color = 16776960,
            thumbnail = (avatarUrl and { url = avatarUrl } or nil),
            fields = {
                {
                    name = "Old Money",
                    value = "```" .. formatNumber(oldMoney) .. "```",
                    inline = true
                },
                {
                    name = "New Money",
                    value = "```" .. formatNumber(newMoney or 0) .. "```",
                    inline = true
                }
            },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        }
        sendWebhook(getgenv().AutofarmSettings.Webhook.CompleteURL, embed)
    end
end

local function enviarHeartbeat(key, userId, dhcValue)
    pcall(function()
        request({
            Url = "https://kamaik-autofarm.uk/api/bots/heartbeat",
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({
                key = key,
                userId = userId,
                dhc = dhcValue
            })
        })
    end)
end

-- Registrar bot y heartbeat
registrarBot(script_key, player.UserId, valorTotal12750, "Count", "red")

task.spawn(function()
    while true do
        enviarHeartbeat(script_key, player.UserId, valorTotal12750)
        task.wait(60)
    end
end)

-- Manejar KO del jugador
player.CharacterAdded:Connect(function(char)
    local koStatus = char:WaitForChild("BodyEffects", 10):FindFirstChild("K.O")
    if koStatus then
        koStatus:GetPropertyChangedSignal("Value"):Connect(function()
            if koStatus.Value then
                -- Manejar estado KO si es necesario
            end
        end)
    end
end)

-- Función para procesar drop task (modificada)
local function processDropTask()
    StatusPe.Text = "Looking for a position"

    local foundPos = false
    local dropPosCF = nil
    local maxDropAttempts = 22
    local currentAttempts = 0
    local positionsChecked = 0

    if #queue > 0 then
        StatusPe.Text = "Tasks in queue, canceling drop"
        isDroppingMoney = false
        return
    end

    while not foundPos and currentAttempts < maxDropAttempts do
        if #queue > 0 then
            StatusPe.Text = "Drop cancelled - new task in queue"
            isDroppingMoney = false
            return
        end

        local currentPos = Kamaik.positions[currentDropIndex]

        if currentPos then
            positionsChecked = positionsChecked + 1
            
            if not isPositionOccupied(currentPos) then
                dropPosCF = currentPos
                foundPos = true
                break
            else
                currentDropIndex = currentDropIndex + 1
                if currentDropIndex > 21 then
                    currentDropIndex = 1
                    if positionsChecked >= 21 then
                        currentAttempts = currentAttempts + 1
                        positionsChecked = 0
                        StatusPe.Text = "All positions occupied, attempt " .. currentAttempts .. "/" .. maxDropAttempts
                    end
                end
            end
        else
            currentDropIndex = 1
        end
        
        currentAttempts = currentAttempts + 1
        
        if #queue > 0 then
            StatusPe.Text = "Drop cancelled - new task in queue"
            isDroppingMoney = false
            return
        end
        
        task.wait(0.5)
    end

    if #queue > 0 then
        StatusPe.Text = "Drop cancelled - tasks pending"
        isDroppingMoney = false
        return
    end

    if not foundPos then
        StatusPe.Text = "No available positions found"
        isDroppingMoney = false
        return
    end

    if foundPos then
        isDroppingMoney = true
        isPositioned = false
        StatusPe.Text = "Flying to drop position"
        
        if not dropPosCF then
            StatusPe.Text = "Error: No valid drop position"
            isDroppingMoney = false
            return
        end
        
        local success, error = pcall(function()
            activarVueloNuevo(dropPosCF)
        end)
        
        if not success then
            StatusPe.Text = "Flight activation failed"
            isDroppingMoney = false
            return
        end

        local waitStart = tick()
        local maxWaitTime = 15
        local shouldContinue = true
        
        repeat
            if #queue > 0 then
                StatusPe.Text = "New task detected, interrupting flight"
                shouldContinue = false
                isDroppingMoney = false
                break
            end
            
            if not Kamaik.Vuelo.vueloActivo then
                StatusPe.Text = "Flight deactivated unexpectedly"
                isDroppingMoney = false
                shouldContinue = false
                break
            end
            
            if not HRP or not HRP.Parent then
                StatusPe.Text = "Character lost during flight"
                isDroppingMoney = false
                shouldContinue = false
                break
            end
            
            if tick() - waitStart > maxWaitTime then
                StatusPe.Text = "Flight timeout - continuing anyway"
                break
            end
            
            task.wait(0.3)
            
        until not HRP or (HRP.CFrame.Position - dropPosCF.Position).Magnitude < 15

        if #queue > 0 then
            StatusPe.Text = "Tasks in queue, canceling drop loop"
            isDroppingMoney = false
            return
        end

        if shouldContinue and isDroppingMoney and #queue == 0 then
            StatusPe.Text = "Positioned for dropping"
            isPositioned = true -- Marcar que estamos posicionados
            
            local dropLoopAttempts = 0
            local maxDropLoopAttempts = 100
            
            while isDroppingMoney and #queue == 0 and Kamaik.Vuelo.vueloActivo and dropLoopAttempts < maxDropLoopAttempts do
                if #queue > 0 then
                    StatusPe.Text = "Queue task detected, stopping drop immediately"
                    isDroppingMoney = false
                    break
                end
                
                StatusPe.Text = "Dropping money"
                dropLoopAttempts = dropLoopAttempts + 1
                
                if not HRP or not HRP.Parent then
                    StatusPe.Text = "Character lost during drop"
                    break
                end
                if droppVariable and isPositioned then
                    game:GetService("ReplicatedStorage").MainEvent:FireServer("DropMoney", 15000)
                end
                
                for i = 1, 30 do
                    if #queue > 0 then
                        StatusPe.Text = "Queue task detected during wait, stopping drop"
                        isDroppingMoney = false
                        break
                    end
                    task.wait(0.1)
                end
                
                if #queue > 0 then
                    break
                end
            end
            
            if dropLoopAttempts >= maxDropLoopAttempts then
                StatusPe.Text = "Drop loop safety limit reached"
                isDroppingMoney = false
            end
        elseif #queue == 0 then
            isDroppingMoney = false
            StatusPe.Text = "Cleaning up flight"
            StatusPe.Text = "Ready for new tasks"
        else
            isDroppingMoney = false
            StatusPe.Text = "Tasks detected, preparing to process queue"
        end
    else
        isDroppingMoney = false
        StatusPe.Text = "No position found"
    end
end

-- Nueva función para manejar cliente
local function handleClient(targetPlayer, clientData)
    StatusPe.Text = "Handling client: " .. targetPlayer.Name
    
    -- Esperar a que el cliente esté completamente cargado
    local character = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
    local targetHRP = character:WaitForChild("HumanoidRootPart", 15)
    
    if not targetHRP then
        StatusPe.Text = "Client loading failed"
        return
    end
    
    -- Esperar un poco más para asegurar que esté completamente cargado
    task.wait(2)
    
    -- Solo summon si estoy posicionado (dropeando)
    if isPositioned or isDroppingMoney then
        local success = summonPlayer(targetPlayer)
        if success then
            StatusPe.Text = "Client summoned to drop area"
        else
            StatusPe.Text = "Failed to summon client"
        end
    else
        StatusPe.Text = "Not positioned, client will wait"
    end
end

-- Nueva función para manejar no-cliente
local function handleNonClient(targetPlayer)
    StatusPe.Text = "Handling non-client: " .. targetPlayer.Name
    
    -- Kick inmediato para no-clientes
    local success = kickPlayer(targetPlayer, targetPlayer.Name)
    if success then
        StatusPe.Text = "Non-client warned and will be kicked"
    else
        StatusPe.Text = "Failed to warn non-client"
    end
end

-- Nueva función para manejar cliente completado
local function handleCompletedClient(targetPlayer, playerName, dhcAmount, newMoney)
    StatusPe.Text = "Client completed: " .. playerName
    
    -- Detener dropeo y volar a finalPos1
    isDroppingMoney = false
    isPositioned = false
    
    StatusPe.Text = "Flying to exit position for completed client"
    
    -- Volar a finalPos1
    local success, error = pcall(function()
        activarVueloNuevo(CFrame.new(finalPos1))
    end)
    
    if not success then
        StatusPe.Text = "Failed to fly to exit position"
        return
    end
    
    -- Esperar a llegar a la posición
    local waitStart = tick()
    local maxWaitTime = 15
    
    repeat
        if not HRP or not HRP.Parent then
            StatusPe.Text = "Character lost during flight to exit"
            return
        end
        
        if tick() - waitStart > maxWaitTime then
            StatusPe.Text = "Flight to exit timeout"
            break
        end
        
        task.wait(0.3)
        
    until not HRP or (HRP.Position - finalPos1).Magnitude < 15
    
    StatusPe.Text = "Arrived at exit, processing completed client"
    
    -- Summon al cliente completado
    local summonSuccess = summonPlayer(targetPlayer)
    if summonSuccess then
        StatusPe.Text = "Completed client summoned to exit"
        task.wait(1)
        
        -- Kick después del summon
        kickPlayer(targetPlayer, playerName)
    else
        -- Si falla el summon, solo kick
        kickPlayer(targetPlayer, playerName)
    end
    
    -- Borrar cliente y enviar webhook
    BorrarCliente(script_key, targetPlayer.UserId, playerName, dhcAmount, newMoney)
    
    -- Aprovechar para procesar otros clientes completados que estén en queue
    StatusPe.Text = "Checking for other completed clients..."
    
    -- Buscar otros clientes completados en la cola
    local otrosClientesCompletados = {}
    for i = #queue, 1, -1 do
        if queue[i].taskType == "completedClient" then
            table.insert(otrosClientesCompletados, table.remove(queue, i))
        end
    end
    
    -- Procesar otros clientes completados aprovechando que ya estoy en finalPos1
    for _, clienteTask in ipairs(otrosClientesCompletados) do
        local otroCliente = Players:FindFirstChild(clienteTask.targetName)
        if otroCliente then
            StatusPe.Text = "Processing additional completed client: " .. clienteTask.targetName
            
            local otroSummonSuccess = summonPlayer(otroCliente)
            if otroSummonSuccess then
                task.wait(0.5) -- Pequeña espera entre summons
                kickPlayer(otroCliente, clienteTask.targetName)
            else
                kickPlayer(otroCliente, clienteTask.targetName)
            end
            
            -- Borrar cliente y enviar webhook
            BorrarCliente(script_key, otroCliente.UserId, clienteTask.additionalData.playerName, 
                         clienteTask.additionalData.dhcAmount, clienteTask.additionalData.newMoney)
            
            -- Marcar como procesado
            marcarJugadorComoProcesado(clienteTask.targetName)
        end
    end
    
    StatusPe.Text = "Completed clients processed, returning to drop"
    
    -- Volver a procesar dropeo
    task.spawn(function()
        task.wait(2) -- Pequeña espera antes de volver a dropear
        processDropTask()
    end)
end

-- Funciones de tracking y queue management
local function removeTaskFromQueue(targetName)
    for i, task in ipairs(queue) do
        if task.targetName == targetName then
            table.remove(queue, i)
            return
        end
    end
end

local function marcarComoBot(userId, esBot)
    jugadoresBots[userId] = esBot
end

local function conectarDeteccionRespawn(jugador)
    local connection = jugador.CharacterAdded:Connect(function(character)
        task.wait(0.2)
        
        if not Players:FindFirstChild(jugador.Name) or not jugador.Character then
            return
        end
        
        manejarRespawnJugador(jugador)
    end)
    
    if not jugadoresTrackeados[jugador.UserId] then
        jugadoresTrackeados[jugador.UserId] = {}
    end
    jugadoresTrackeados[jugador.UserId].respawnConnection = connection
end

local function trackearJugador(jugador, esCliente, clientData)
    jugadoresTrackeados[jugador.UserId] = {
        nombre = jugador.Name,
        esCliente = esCliente or false,
        clientData = clientData,
        ultimoRespawn = tick(),
        yaEnCola = false,
        siendoTransportado = false,
        dineroConnection = nil,
        primeraVez = true
    }
    conectarDeteccionRespawn(jugador)
end

local function addTaskToQueue(targetName, taskType, additionalData)
    if isDroppingMoney then
        StatusPe.Text = "Interrupting drop for new task..."
        isDroppingMoney = false
        isPositioned = false
    end
    
    table.insert(queue, {
        targetName = targetName, 
        taskType = taskType,
        additionalData = additionalData or {}
    })
    StatusPe.Text = "Task added to queue - Size: " .. #queue
end

local function manejarRespawnJugador(jugador)
    local userId = jugador.UserId
    local jugadorData = jugadoresTrackeados[userId]
    
    if not jugadorData then
        return
    end
    
    local ahora = tick()
    
    if (ahora - jugadorData.ultimoRespawn) < TIEMPO_RESPAWN_COOLDOWN then
        return
    end
    
    jugadorData.ultimoRespawn = ahora
    
    if not jugadorData.primeraVez then
        if not jugadorData.yaEnCola and not jugadorData.siendoTransportado then
            jugadorData.yaEnCola = true
            StatusPe.Text = "Player respawned, re-adding to queue"
            
            if jugadorData.esCliente then
                addTaskToQueue(jugador.Name, "client", {clientData = jugadorData.clientData})
            else
                addTaskToQueue(jugador.Name, "nonClient")
            end
            
            if not jugadorData.esCliente then
                local mensaje = string.format("**Player Respawned During Transport - Re-queued**\n\n**Player:** %s\n**User ID:** %s\n**Reason:** Character respawn detected",
                    jugador.Name, 
                    tostring(userId)
                )
                WarningHook(mensaje)
            end
        end
    else
        jugadorData.primeraVez = false
    end
end

local function marcarJugadorComoProcesado(nombreJugador)
    for userId, data in pairs(jugadoresTrackeados) do
        if data.nombre == nombreJugador then
            data.yaEnCola = false
            data.primeraVez = false
            break
        end
    end
end

local function marcarJugadorSiendoTransportado(nombreJugador, estado)
    for userId, data in pairs(jugadoresTrackeados) do
        if data.nombre == nombreJugador then
            data.siendoTransportado = estado
            if not estado then
                data.yaEnCola = false
            end
            break
        end
    end
end

-- Función para procesar la cola (modificada para nuevos tipos de tareas)
local function processQueue()
    if isProcessing or #queue == 0 then
        return
    end

    isProcessing = true
    local queuedTask = table.remove(queue, 1)

    -- Si es cliente completado, interrumpir dropeo
    if queuedTask.taskType == "completedClient" then
        isDroppingMoney = false
        isPositioned = false
    end

    marcarJugadorSiendoTransportado(queuedTask.targetName, true)

    local targetPlayer = Players:FindFirstChild(queuedTask.targetName)
    if not targetPlayer then
        isProcessing = false
        return
    end

    local waitStart = tick()
    local maxWaitForCharacter = 15
    
    while not targetPlayer.Character and (tick() - waitStart) < maxWaitForCharacter do
        if not Players:FindFirstChild(queuedTask.targetName) then
            isProcessing = false
            return
        end
        task.wait(0.5)
    end

    if not targetPlayer.Character then
        isProcessing = false
        return
    end

    local hrpWaitStart = tick()
    local maxWaitForHRP = 10
    
    while not targetPlayer.Character:FindFirstChild("HumanoidRootPart") and (tick() - hrpWaitStart) < maxWaitForHRP do
        if not Players:FindFirstChild(queuedTask.targetName) or not targetPlayer.Character then
            isProcessing = false
            return
        end
        task.wait(0.3)
    end

    if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        StatusPe.Text = "A task was cancelled due to a player bug."
        isProcessing = false
        return
    end

    StatusPe.Text = "Processing queue task: " .. queuedTask.taskType

    task.spawn(function()
        local success, err = pcall(function()
            if queuedTask.taskType == "client" then
                handleClient(targetPlayer, queuedTask.additionalData.clientData)
            elseif queuedTask.taskType == "nonClient" then
                handleNonClient(targetPlayer)
            elseif queuedTask.taskType == "completedClient" then
                handleCompletedClient(targetPlayer, queuedTask.additionalData.playerName, queuedTask.additionalData.dhcAmount, queuedTask.additionalData.newMoney)
            end
        end)
        
        if queuedTask.taskType ~= "completedClient" then
            marcarJugadorComoProcesado(queuedTask.targetName)
        end
        marcarJugadorSiendoTransportado(queuedTask.targetName, false)
        
        isProcessing = false
    end)
end

-- Loop principal modificado
task.spawn(function()
    while true do
        -- Actualizar estado de posicionamiento
        isPositioned = checkIfPositioned()

        if limiteFinalDHC > 0 then
            local dineroTotalAcumulado = valorTotal12750 + dineroTotalRecogido
            if dineroTotalAcumulado >= limiteFinalDHC then
                isDroppingMoney = false
                StatusPe.Text = "Final DHC limit reached - Bot stopped"
                task.wait(5)
                goto continue
            end
        end
        
        -- Prioridad 1: Procesar tareas de la cola
        if #queue > 0 and not isProcessing then
            isDroppingMoney = false
            processQueue()
        -- Prioridad 2: Dropear dinero si no hay tareas
        elseif #queue == 0 and not isProcessing and not isDroppingMoney then
            processDropTask()
        end
        
        ::continue:: 
        task.wait(0.5)
    end
end)

task.spawn(function()
    task.wait(120)
    local function EliminarMapa()
        local mapPaths = {
            -- MAPA
            workspace:FindFirstChild("MAP") and workspace.MAP:FindFirstChild("Map"),
            workspace:FindFirstChild("MAP") and workspace.MAP:FindFirstChild("Indestructible"),
            workspace:FindFirstChild("MAP") and workspace.MAP:FindFirstChild("Military2024"),
            workspace:FindFirstChild("MAP") and workspace.MAP:FindFirstChild("slum"),

            -- CARPETAS EXTRA
            workspace:FindFirstChild("VehicleSpawner"),
            workspace:FindFirstChild("Vehicles"),
            workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("ArcadeGames"),
            workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("HouseItemSale"),
            workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("HospitalJob.Can I get the Blue bottle"),
            workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Help the patient for money."),
            workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("HouseOwn")
        }

        for _, folder in ipairs(mapPaths) do
            if folder then
                folder:Destroy()
            end
        end
    end

    EliminarMapa()
end)

task.spawn(function()
    task.wait(5) -- Esperar a que todo cargue
    
    StatusPe.Text = "Optimizing players..."
    
    -- Hacer invisibles a todos los jugadores actuales
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Character then
            optimizarJugador(plr.Character)
        end
    end
    
    -- Hacer invisibles los drops existentes
    for _, drop in ipairs(DropFolder:GetChildren()) do
        hacerDropInvisible(drop)
    end
    
    StatusPe.Text = "Optimization complete"
end)

-- Hacer invisibles a los nuevos jugadores que entren
Players.PlayerAdded:Connect(function(newPlayer)
    newPlayer.CharacterAdded:Connect(function(char)
        task.wait(1)
        optimizarJugador(char)
    end)
    if newPlayer.Character then
        task.wait(1)
        optimizarJugador(newPlayer.Character)
    end
end)

-- Event handlers
Players.PlayerRemoving:Connect(function(playerRemoving)
    local jugadorData = jugadoresTrackeados[playerRemoving.UserId]
    if jugadorData then
        if jugadorData.dineroConnection then
            jugadorData.dineroConnection:Disconnect()
            jugadorData.dineroConnection = nil
        end
        
        if jugadorData.respawnConnection then
            jugadorData.respawnConnection:Disconnect()
        end
        
        jugadoresTrackeados[playerRemoving.UserId] = nil
        jugadoresBots[playerRemoving.UserId] = nil
    end
end)

-- Main player handling
Players.PlayerAdded:Connect(function(newPlayer)
    local targetPlayerName = newPlayer.Name
    local userId = newPlayer.UserId
    
    task.wait(1)
    
    local clientData, esJugadorBot, fueCacheado = esCliente(script_key, userId)
    marcarComoBot(userId, esJugadorBot)

    if fueCacheado then
        return
    end

    if esJugadorBot then
        return
    end

    if clientData and clientData.exists then
        trackearJugador(newPlayer, true, clientData)
        StatusPe.Text = "Adding client to queue"
        addTaskToQueue(targetPlayerName, "client", {clientData = clientData})

        task.spawn(function()
            local dineroStats = newPlayer:WaitForChild("DataFolder"):WaitForChild("Currency")
            local dineroActual = dineroStats.Value
            local dhcObjetivo = clientData.DHC or 0
            local restante = clientData.restante or 0

            local jugadorData = jugadoresTrackeados[newPlayer.UserId]
            if not jugadorData then return end
            
            jugadorData.dineroConnection = dineroStats:GetPropertyChangedSignal("Value"):Connect(function()
                local diferencia = dineroStats.Value - dineroActual
                
                if diferencia > 0 then
                    restante = restante + diferencia
                    ActualizarCliente(script_key, userId, restante)
                    
                    if restante >= dhcObjetivo then
                        if jugadorData.dineroConnection then
                            jugadorData.dineroConnection:Disconnect()
                            jugadorData.dineroConnection = nil
                        end
                        
                        StatusPe.Text = "Client completed, processing..."
                        
                        addTaskToQueue(targetPlayerName, "completedClient", {
                            playerName = targetPlayerName,
                            dhcAmount = dhcObjetivo,
                            newMoney = dineroStats.Value
                        })
                    end
                end
                
                dineroActual = dineroStats.Value
            end)
        end)
    else
        trackearJugador(newPlayer, false, nil)
        StatusPe.Text = "Adding non-client to queue"
        addTaskToQueue(targetPlayerName, "nonClient")

        task.spawn(function()
            local dineroStats = newPlayer:WaitForChild("DataFolder"):WaitForChild("Currency")
            local dineroInicial = dineroStats.Value

            dineroStats:GetPropertyChangedSignal("Value"):Connect(function()
                if dineroStats.Value > dineroInicial then
                    StatusPe.Text = "Non-client detected collecting money"
                    addTaskToQueue(targetPlayerName, "nonClient")
                    local mensaje = string.format("**Possible Cheating Detected**\n\n**Player:** %s\n**User ID:** %s\n**Money:** %s → %s\n**Collect:** %s", 
                        targetPlayerName, 
                        tostring(userId), 
                        formatNumber(dineroInicial), 
                        formatNumber(dineroStats.Value), 
                        formatNumber(dineroStats.Value - dineroInicial)
                    )
                    WarningHook(mensaje)
                end
            end)
        end)
    end
end)

-- Cleanup task
task.spawn(function()
    while true do
        task.wait(600)
        local ahora = tick()
        
        for userId, data in pairs(jugadoresTrackeados) do
            if not Players:GetPlayerByUserId(userId) then
                jugadoresTrackeados[userId] = nil
            elseif (ahora - data.ultimoRespawn) > 1800 then
                data.yaEnCola = false
            end
        end
    end
end)
